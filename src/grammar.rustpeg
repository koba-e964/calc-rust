use ast::*;
use parse::*;

#[pub]
top_exp -> AST
        = space* fundec* space* e:exp space* { e }
fundec -> ()
        = "def" space* ident space*
          "(" space* ident space* ":" space* ident space* ")" space*
          "{" space* exp space* "}"
exp -> AST
	= letex
        / add_ast
letex -> AST
        = "let" space+ x:ident space* "=" space* e1:exp space+ "in" space+ e2:exp
           { AST::LetEx(x, Box::new(e1), Box::new(e2)) }
add_ast -> AST
        = e:sum { super::vecast_to_ast(e, |op, l, r| AST::OpNode(op, Box::new(l), Box::new(r))) }
sum -> (Vec<(AST, Op)>, AST)
	= l:mul_ast space* op:addop space* r:sum { {let (mut x, y) = r; x.push((l, op)); (x, y)} }
	/ e:mul_ast { (Vec::new(), e) }
addop -> Op
        = "+" { Op::Add }
        / "-" { Op::Sub }
mul_ast -> AST
        = e:product { super::vecast_to_ast(e, |op, l, r| AST::OpNode(op, Box::new(l), Box::new(r))) }
product -> (Vec<(AST, Op)>, AST)
	= l:atom space* op:mulop space* r:product { {let (mut x, y) = r; x.push((l, op)); (x, y)} }
	/ e:atom { (Vec::new(), e) }
mulop -> Op
        = "*" { Op::Mul }
        / "/" { Op::Div }
atom -> AST
	= number
        / str
	/ v:ident space* "(" space* e:exp space* ")" { AST::FunApp(v, vec![e]) }
        / v:ident { AST::Var(v) }
	/ "(" space* v:exp space* ")" { v }
number -> AST
	= [0-9]+ { AST::Num(match_str.parse().unwrap()) }
str -> AST
        = "\"" s:str_internal "\"" { AST::Str(s) }
str_internal -> String
        = [^\"]* { match_str.to_string() }
space -> ()
        = " " / "\n" / "\r"
ident -> String
        = [a-zA-Z]+ { match_str.to_string() }
